<kbd>GO</kbd>

## 数组
### 二分查找
4，34，35，69，704
### 消除元素&有序数组的平方
26，27，283，844，977
>快慢指针：
1.消除元素：fast遍历数组，slow生成新数组
2.双指针逆序放入
### 长度最小的子数组
209，904，76
>滑动窗口:调整子序列的起始位置(slow指针)和终止位置(fast指针)
### 螺旋矩阵
54，59

## 链表
203,707,206,24,19,142
1.移除元素203
2.设计链表707
3.翻转链表206：双指针（通过前后两指针调转每两个节点之间的指针方向 ->到<-）
4.两两交换链表中的节点24：pre,head,next三指针
5.删除链表倒数第n个节点19：前后双指针
6.环形链表142：判定有无环，快慢指针，判断环入口(fast一次走两个节点，slow一次一个节点)

## 哈希表
242,349,202
（快速判断一个元素是否出现在集合里）
1.有效的字母异位词：242
2.两个数字的交集：349
3.快乐数：202   ？

## 字符串
541，344，151，28，459
```go
// 翻转字符串
func reverse(b []byte,left,right int){
    for left<right{
        b[left],b[right]=b[right],b[left]
        left++
        right--
    }
}
```
1、反转字符串：541、344类似始末双指针，left和right互换值
2、反转字符串中的单词：151；先移除多余的空格，将整个字符产翻转过来，再根据空格将每个单词翻转。
3、左旋转字符串：
输入: s = "abcdefg", k = 2
输出: "cdefgab"
（1）旋转前n个字符（2）翻转n到end的字符（3）翻转整个字符
4、找出字符串中第一个匹配项的下标（**KMP算法实现字符串匹配**）：28；  .？
>文本串中找模式串，前缀后缀针对模式串的当前判定到的节点的之前的节点
next数组是就是前缀表
i < j,如果str[i]==str[j]，则str[i-1]==str[j-1]（前缀和后缀相等）   

5、重复的子字符串：459
